#!/bin/sh
# shwa

basename() {
	: "${1?basename: expected path}"
	set -- "${1%"${1##*[!/]}"}" "$2"
	set -- "${1##*/}" "$2"
	set -- "${1%"$2"}"
	out "$1"
}

bsf() {
	[ -b "${1?bsf: expected path}" ]
}

count() {
	out "$#"
}

csf() {
	[ -c "${1?csf: expected path}" ]
}

decimal() {
	: "${1?decimal: expected argument}"
	! match "''"'|*.*.*|*[!0-9.]*|*.' "${1#[+-]}"
}

default() {
	while [ $# -gt 0 ]; do
		if has "$1"; then
			out "$1"
			return
		fi
	done
	false
}

dirname() {
	: "${1?dirname: expected path}"
	set -- "${1%%"${1##*[!/]}"}"
	[ "${1##*/*}" ] && set -- '.'
	set -- "${1%/*}"
	set -- "${1%%"${1##*[!/]}"}"
	out "${1:-/}"
}

directory() {
	[ -d "${1?directory: expected path}" ]
}

dump() {
	set -x
	if name "${1?dump: expected list (name)}"; then
		eval '
			eval set -- $'"$1"'
			printf %b\\n "$@"
		'
	else
		err "dump: bad list (name)"
	fi
	set +x
}

empty() {
	! [ -s "${1?empty: expected path}" ]
}

err() {
	out "$@" >&2
}

executable() {
	[ -x "${1?executable: expected path}" ]
}

exists() {
	[ -e "${1?exists: expected path}" ]
}

fifo() {
	[ -p "${1?fifo: expected path}" ]
}

get() {
	# This might conflict with some (optional) ANCIENT version control stuff, which would suck.
	# If this ever comes up
	# in practice I will add some kind of protection mechanism or rename this function?
	# `nab` or `see` sound like maybe the best alternatives?

	if name "${1?get: expected name}"; then
		# I do not like that there is no syntax highlighting for eval blocks.
		# Rather, I wish there was actual proper syntax for delayed expansion instead
		# of having to wrap entire expressions in eval and injecting variables directly
		# as string concats outside the context of the eval environment (for the duration
		# of execution, obviously eval will effect the current shell environment directly
		# and will not require subshell).
		eval '[ "${'"$1"'+.}" ] && printf "%s\n" "$'"$1"'"'
	else
		err "get: bad name"
	fi
}

has() {
	2>/dev/null >&2 command -V "${1?has: expected command}"
}

integer() {
	natural "${1#[+-]}"
}

lay() {
	if name "${1?lay: expected list (name)}"; then
		eval 'shift; '"$1"'="$(quote "$@")"'
	else
		err "lay: bad list (name)"
	fi
}

length() {
	if name "${1?length: expected list (name)}"; then
		eval eval count '$'"$1"
	else
		err "length: bad list (name)"
	fi
}

match() {
	eval '
		case "$2" in
			'"${1?match: expected pattern}"') return 0;;
		esac
		return 1
	'
}

name() {
	! match "''"'|[!_a-zA-Z]*|*[!_a-zA-Z0-9]*' "${1?name: expected argument}"
}

natural() {
	! match "''"'|*[!0-9]*' "${1?natural: expected argument}"
}

null() {
	[ -z "${1?null: expected argument}" ]
}

out() {
	# Stupid simple, essentially a replacement for `echo`
	[ $# -gt 0 ] && printf '%s\n' "$@" 
}

peek() {
	if name "${1?peek: expected list (name)}"; then
		if [ $# -eq 1 ] || natural "$2"; then
			eval '
				eval set -- $'"$1"'
				2>/dev/null shift "'"${2-0}"'" || return
				[ $# -eq 0 ] || return
				out "$1"
			'
		else
			err "peek: bad index"
		fi
	else
		err "peek: bad list (name)"
	fi
}

pop() {
	if ! name "${1?pop: expected source (name)}"; then
		err "pop: bad source (name)"
		return
	fi

	if ! name "${2?pop: expected target (name)}"; then
		err "pop: bad target (name))"
		return
	fi

	eval '
		eval set -- $'"$1"'
		'"$2"'=$1
		2>/dev/null shift || return
		# This requote of the whole argument list seems... wrong?
		# Like if this is placed in a hot loop...
		'"$1"'="$(quote "$@")"
	'
}

printfq() {
	# shellcheck disable=SC2139
	# This assignment is explicitly gathering this functions arguments and packing them into
	# the alias to exploit its expansion for free quoting.
	: "${1?printfq: expected format}"

	# TODO: Instead of checking for names, which is a weak selection that will miss a lot of obviously
	# optimizable stuff, we should check for 'safe' strings that will not cause any harm when
	# expanded into a shell command. Reversing this out long enough should get us close to something
	# properly usable that avoids the maximum number of possible subshells.
	if name "$2"; then
		# Still add quotes so we can perform certain nicety operations on quoted lists
		# that mean we don't need to throw an entire list into a requote during hot routines
		set -- "$1" "'$2'"
	else
		# shellcheck disable=SC2139
		set -- "$1" "$(alias _="$2"; alias _)"
		set -- "$1" "${2#??}"
	fi
	# shellcheck disable=SC2059
	# This function is an explicit mask for printf's functionality
	printf "$@"
}

push() {
	if name "${1?push: expected list (name)}"; then
		eval 'shift; '"$1"'="${1+$(quote "$@") }${'"$1"'}"'
	else
		err "push: bad list (name)"	
	fi
}

put() {
	if name "${1?put: expected name}"; then
		if [ $# -gt 1 ]; then
			eval 'shift; '"$1"'=$*'
		else
			eval 'shift; '"$1"'="$(cat)"'
		fi
	else
		err "put: bad name"
	fi
}

putq() {
	if name "${1?putq: expected name}"; then
		if [ $# -gt 1 ]; then
			eval 'shift; '"$1"'="$(quote "$*")"'
		else
			eval 'shift; '"$1"'="$(qat)"'
		fi
	else
		err "putq: bad name"
	fi
}

# TODO: Helpers for terminal control sequences

qat() {
	set -- "$(cat "$@"; printf .)" # Hang final character off of output to save trailing whitespace
	quote "${1%?}"
}

queue() {
	if name "${1?queue: expected list (name)}"; then
		eval 'shift; '"$1"'="${'"$1"'+$'"$1"' }$(quote "$@")"'
	else
		err "queue: bad list (name)"
	fi
}

quote() {
	# Output of this command will always be safe to pass as argument(s) to a command in an eval

	if [ $# -gt 0 ]; then
		while [ $# -gt 1 ]; do
			printfq '%s ' "$1"
			shift
		done

		printfq '%s\n' "$1"
		return
	fi

	# This is heinously ugly but
	# allows input to be directly quote-ified by
	# standard i/o on a line-by-line basis like the UNIX GODS intended
	# If you want to prevent this behavior from stealing standard input
	# Attach standard input to the null file (</dev/null)
	(
	FIRST=1
	while IFS= read -r LINE || [ "$LINE" ]; do
		if [ "$FIRST" ]; then
			printfq '%s' "$LINE"
			unset FIRST
		else
			printfq ' %s' "$LINE"
		fi
	done
	[ "$FIRST" ] || printf '\n'
	)
}

readable() {
	[ -r "${1?readable: expected path}" ]
}

regular() {
	[ -f "${1?regular: expected path}" ]
}

same() {
	[ $# -ne 1 ] || return
	[ $# -eq 0 ] && return

	while [ $# -gt 1 ]; do
		[ "$1" = "$2" ] && shift || return
	done
}

sgid() {
	[ -g "${1?sgid: expected path}" ]
}

socket() {
	[ -S "${1?socket: expected path}" ]
}

suid() {
	[ -u "${1?suid: expected path}" ]
}

symlink() {
	[ -h "${1?symlink: expected path}" ]
}

terminal() {
	[ -t "${1-0}" ]
}

writeable() {
	[ -w "${1?writeable: expected path}" ]
}

export SHWA=1
