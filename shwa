#!/bin/sh
# shwa

shwa() {
	>&2 printf '%s: %s\n' "$0" 'not supported'
}

# Both of these implementations (dirname, basename) are ripped directly from
# dylanaraps' pure-sh-bible, but with the variable assignments replaced with
# argument list assignments (preventing damage to the scope).

dirname() {
	set -- "${1:-.}"
	set -- "${1%%"${1##*[!/]}"}"
	[ "${1##*/*}" ] && set -- '.'
	set -- "${1%/*}"
	set -- "${1%%"${1##*[!/]}"}"
	printf '%s\n' "${1:-/}"
}

basename() {
	set -- "${1%${1##*[!/]}}" "$2"
	set -- "${1##*/}" "$2"
	set -- "${1%"$2"}"
	printf '%s\n' "${1:-/}"
}

# TODO: Helpers for terminal control sequences

quote() {
	while true; do
		case "$#" in
			0) return;;
			1) printfq '%s\n' "$1"; return;;
			*) printfq '%s ' "$1"; shift;;
		esac
	done
}

printfq() {
	set -- "${1:?printfq: expected format}" "$(shift; alias _="$*"; alias _)"
	printf "$1" "${2#??}"
}

put() {
	is_name "${1?put: expected name}" || { >&2 printf '%s: %s\n' "put" "invalid name"; return; }
	eval 'shift; '"$1"'=$*'
}

lay() {
	is_name "${1:?lay: expected name}" || { >&2 printf '%s: %s\n' "lay" "invalid name"; return; }
	eval 'shift; '"$1"'="$(quote "$@")"'
}

push() {
	is_name "${1:?push: expected name}" || { >&2 printf '%s: %s\n' "push" "invalid name"; return; }
	eval 'shift; '"$1"'="${1+$(quote "$@") }${'"$1"'}"'
}

queue() {
	is_name "${1:?queue: expected name}" || { >&2 printf '%s: %s\n' "queue" "invalid name"; return; }
	eval 'shift; '"$1"'="${'"$1"'+$'"$1"' }$(quote "$@")"'
}

pop() {
	is_name "${1:?pop: expected name (source)}" || { >&2 printf '%s: %s\n' "pop" "invalid name (source)"; return; }
	is_name "${2:?pop: expected name (target)}" || { >&2 printf '%s: %s\n' "pop" "invalid name (target)"; return; }
	eval '
		eval set -- $'"$1"'
		'"$2"'=$1
		2>/dev/null shift || return
		# This requote of the whole argument list seems... wrong?
		'"$1"'="$(quote "$@")"
	'
}

peek() {
	is_name "${1:?peek: expected name}" || { >&2 printf '%s: %s\n' "peek" "invalid name"; return; }
	eval '
		eval set -- $'"$1"'
		2>/dev/null shift "'${2:-0}'" || return
		printf "%s\n" "$1"
	'
}

length() {
	is_name "${1:?length: expected name}" || { >&2 printf '%s: %s\n' "length" "invalid name"; return; }
	eval '
		eval set -- $'"$1"'
		printf "%d\n" "$#"
	'
}

nab() {
	is_name "${1:?nab: expected name}" || { >&2 printf '%s: %s\n' "nab" "invalid name"; return; }
	eval 'printf "%s\n" "$'"$1"'"'
}

is() {
	is_command "is_${1:?is: expected command}" || { >&2 printf '%s: %s\n' "is" "invalid command"; return; }
	is_"$@"
}

is_command() {
	2>/dev/null >&2 command -V "$1"
}

is_name() {
	case "$1" in
		''|[!_a-zA-Z]*|*[!_a-zA-Z0-9]*) false;;
	esac
}

is_natural() {
	case "$1" in
		''|*[!0-9]*) false;;
	esac
}

is_decimal() {
	case "${1#[+-]}" in
		''|*.*.*|*[!0-9.]*|*.) false;;
	esac
}

is_integer() {
	is_natural "${1#[+-]}"
}

is_block() {
	test -b "$1"
}

is_character() {
	test -c "$1"
}

is_directory() {
	test -d "$1"
}

is_file() {
	test -e "$1"
}

is_regular() {
	test -f "$1"
}

is_sgid() {
	test -g "$1"
}

is_symlink() {
	test -h "$1"
}

is_fifo() {
	test -p "$1"
}

is_readable() {
	test -r "$1"
}

is_nonempty() {
	test -s "$1"
}

is_empty() {
	! test -s "$1"
}

is_terminal() {
	test -t "$1"
}

is_suid() {
	test -u "$1"
}

is_writeable() {
	test -w "$1"
}

is_executable() {
	test -x "$1"
}

is_socket() {
	test -S "$1"
}

is_zero() {
	test -z "$1"
}

is_nonzero() {
	test -n "$1"
}

is_same() {
	while [ $# -gt 1 ]; do
		[ "$1" = "$2" ] || return
	done
}

is_different() {
	while [ $# -gt 1 ]; do
		[ "$1" != "$2" ] || return
	done
}

[ 'shwa' = "${0##*/}" ] && shwa "$@"
